#include "estate_private.h"

EAPI Estate_Transition *
estate_transition_new(Estate_Machine *mach EINA_UNUSED)
{
   /* XXX Use mach allocator */
   return calloc(1, sizeof(Estate_Transition));
}

EAPI void
estate_transition_free(Estate_Transition *tr)
{
   /* XXX Update when mach allocator will be used */
   free(tr);
}

EAPI Eina_Bool
estate_transition_init(Estate_Transition  *tr,
                       const char         *name,
                       const Estate_State *from,
                       const Estate_State *to,
                       Estate_Cb           func,
                       void               *data)
{
   EINA_SAFETY_ON_NULL_RETURN_VAL(tr, EINA_FALSE);
   EINA_SAFETY_ON_NULL_RETURN_VAL(name, EINA_FALSE);
   EINA_SAFETY_ON_NULL_RETURN_VAL(from, EINA_FALSE);
   EINA_SAFETY_ON_NULL_RETURN_VAL(to, EINA_FALSE);

   tr->name = name;
   tr->from = (Estate_State *)from;
   tr->to = (Estate_State *)to;
   tr->cb.func = func;
   tr->cb.data = data;

   return EINA_TRUE;
}

EAPI void
estate_transition_deinit(Estate_Transition *tr EINA_UNUSED)
{
   /* Nothing to do... */
}

EAPI Eina_Bool
estate_transition_do(Estate_Machine *mach,
                     const char     *transition)
{
   EINA_SAFETY_ON_NULL_RETURN_VAL(mach, EINA_FALSE);
   EINA_SAFETY_ON_NULL_RETURN_VAL(transition, EINA_FALSE);

   Estate_Transition *tr;
   Eina_Stringshare *shr;
   Eina_Array_Iterator iter;
   unsigned int i;
   Eina_Bool found = EINA_FALSE;

   /* For immediate search */
   shr = eina_stringshare_add(transition);

   /* Find transition */
   EINA_ARRAY_ITER_NEXT(mach->current_state->transit, i, tr, iter)
     {
        /* Stringshares... I can do that */
        if (tr->name == shr)
          {
             found = EINA_TRUE;
             break;
          }
     }

   /* Gracefully fail if no transition is available */
   if (!found)
     {
        ERR("Could not find transition \"%s\" at current state (%s)",
            transition, mach->current_state->name);
        goto fail;
     }

   /* Safety check: is the transition really coming from the current state?
    * This should never fail when the machine is generated by estate_cc. */
   if (EINA_UNLIKELY(tr->from != mach->current_state))
     {
        CRI("Wtf?! Transition \"%s\" is inconsistent", tr->name);
        goto fail;
     }

   /* Call exiter callback of current state */
   _estate_state_cb_call(mach, tr->from, tr, ESTATE_CB_TYPE_EXITER);

   /* Execute the transition callback */
   if (tr->cb.func)
     {
        _estate_misc_cb_cache(mach, &tr->cb);
        tr->cb.func(tr->cb.data, ESTATE_CB_TYPE_TRANSITION, tr);
     }

   /* Call enterer callback of next state */
   _estate_state_cb_call(mach, tr->to, tr, ESTATE_CB_TYPE_ENTERER);

   /* Update current state */
   mach->current_state = tr->to;

   eina_stringshare_del(shr);
   return EINA_TRUE;

fail:
   if (shr) eina_stringshare_del(shr);
   return EINA_FALSE;
}

